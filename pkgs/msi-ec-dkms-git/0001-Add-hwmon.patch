From 8ea0037f4b88c83013cc2636e48ccbac24c9ec87 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Thu, 6 Mar 2025 17:35:50 +0800
Subject: [PATCH 01/10] Add Claw 8

---
 msi-ec.c | 68 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/msi-ec.c b/msi-ec.c
index 4d55ebb..52a1c57 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -2886,6 +2886,73 @@ static struct msi_ec_conf CONF40 __initdata = {
 	},
 };
 
+static const char *ALLOWED_FW_401[] __initconst = {
+	"1T52EMS1.104", // MSI Claw 8 AI+ A2VM
+	NULL
+};
+
+static struct msi_ec_conf CONF401 __initdata = {
+	.allowed_fw = ALLOWED_FW_401,
+	.charge_control_address = 0xd7,
+	.webcam = {
+		.address       = MSI_EC_ADDR_UNSUPP,
+		.block_address = 0x2f,
+		.bit           = 1,
+	},
+	.fn_win_swap = {
+		.address = MSI_EC_ADDR_UNSUPP,
+		.bit     = 4,
+		.invert  = false,
+	},
+	.cooler_boost = {
+		.address = 0x98,
+		.bit     = 7,
+	},
+	.shift_mode = {
+		.address = 0xd2,
+		.modes = {
+			{ SM_ECO_NAME,     0xc2 },
+			{ SM_COMFORT_NAME, 0xc1 },
+			{ SM_SPORT_NAME,   0xc0 },
+			MSI_EC_MODE_NULL
+		},
+	},
+	.super_battery = {
+		.address = MSI_EC_ADDR_UNSUPP,
+		.mask    = 0x0f,
+	},
+	.fan_mode = {
+		.address = 0xd4,
+		.modes = {
+			{ FM_AUTO_NAME,     0x0d },
+			{ FM_SILENT_NAME,   0x1d },
+			{ FM_ADVANCED_NAME, 0x8d },
+			MSI_EC_MODE_NULL
+		},
+	},
+	.cpu = {
+		.rt_temp_address       = 0x68,
+		.rt_fan_speed_address  = 0x71,
+	},
+	.gpu = {
+		.rt_temp_address      = 0x80,
+		.rt_fan_speed_address = 0x89,
+	},
+	.leds = {
+		.micmute_led_address = MSI_EC_ADDR_UNSUPP,
+		.mute_led_address    = MSI_EC_ADDR_UNSUPP,
+		.bit                 = 1,
+	},
+	.kbd_bl = {
+		.bl_mode_address  = MSI_EC_ADDR_UNSUPP, // KB auto turn off
+		.bl_modes         = { 0x00, 0x08 }, // always on; off after 10 sec
+		.max_mode         = 1,
+		.bl_state_address = MSI_EC_ADDR_UNSUPP,
+		.state_base_value = 0x80,
+		.max_state        = 3,
+	},
+};
+
 static const char *ALLOWED_FW_41[] __initconst = {
 	"15M1IMS2.111", // MSI Vector 16 HX A14VHG
 	NULL
@@ -3060,6 +3127,7 @@ static struct msi_ec_conf *CONFIGURATIONS[] __initdata = {
 	&CONF38,
 	&CONF39,
 	&CONF40,
+	&CONF401,
 	&CONF41,
 	&CONF42,
 	NULL
-- 
2.39.1


From 2d5c2c8a9e2764992d625f5a826718f42930c7dd Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Thu, 6 Mar 2025 17:36:14 +0800
Subject: [PATCH 02/10] Implement Fan Thermal Curve

---
 ec_memory_configuration.h |  28 +++
 msi-ec.c                  | 375 +++++++++++++++++++++++++++++++++++++-
 2 files changed, 397 insertions(+), 6 deletions(-)

diff --git a/ec_memory_configuration.h b/ec_memory_configuration.h
index ff9503f..8e59048 100644
--- a/ec_memory_configuration.h
+++ b/ec_memory_configuration.h
@@ -55,14 +55,42 @@ struct msi_ec_fan_mode_conf {
 	struct msi_ec_mode modes[5]; // fixed size for easier hard coding
 };
 
+/**
+ * Curve maximum entries (should be more than real maximum for extensibility).
+ */
+#define CURVE_MAX_ENTRIES 16
+
+/**
+ * Persists curve in 
+ */
+#define CURVE_APPLY_STRATEGY_NORMAL 0
+
+/**
+ * Resets curve from ec to default when auto mode is turned on.
+ * Required on some devices where auto mode is broken by custom curve in EC.
+ */
+#define CURVE_APPLY_STRATEGY_RESET_ON_AUTO 1
+
+// Curve start address and entries count.
+struct msi_ec_fan_curve {
+	int speed_start_address;
+	int temperature_start_address;
+	int entries_count;
+
+	// Defaults to CURVE_APPLY_STRATEGY_NORMAL
+	int apply_strategy;
+};
+
 struct msi_ec_cpu_conf {
 	int rt_temp_address;
 	int rt_fan_speed_address; // realtime % RPM
+	struct msi_ec_fan_curve fan_curve;
 };
 
 struct msi_ec_gpu_conf {
 	int rt_temp_address;
 	int rt_fan_speed_address; // realtime % RPM
+	struct msi_ec_fan_curve fan_curve;
 };
 
 struct msi_ec_led_conf {
diff --git a/msi-ec.c b/msi-ec.c
index 52a1c57..3c0a25a 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -3719,27 +3719,42 @@ static ssize_t available_fan_modes_show(struct device *device,
 	return count;
 }
 
-static ssize_t fan_mode_show(struct device *device,
-			     struct device_attribute *attr, char *buf)
-{
+static int fan_mode_get(const char **const dst) {
 	u8 rdata;
 	int result;
 
 	result = ec_read(conf.fan_mode.address, &rdata);
 	if (result < 0)
 		return result;
-
 	for (int i = 0; conf.fan_mode.modes[i].name; i++) {
 		// NULL entries have NULL name
 
 		if (rdata == conf.fan_mode.modes[i].value) {
-			return sysfs_emit(buf, "%s\n", conf.fan_mode.modes[i].name);
+			*dst = conf.fan_mode.modes[i].name;
+			return 0;
 		}
 	}
 
-	return sysfs_emit(buf, "%s (%i)\n", "unknown", rdata);
+	if (rdata == 0) return MSI_EC_ADDR_UNSUPP;
+	return rdata;
 }
 
+static ssize_t fan_mode_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
+{
+	const char *attr_name;
+	int status = fan_mode_get(&attr_name);
+
+	if (status < 0) return status;
+	else if (status == 0) return sysfs_emit(buf, "%s\n", attr_name);
+	else return sysfs_emit(buf, "%s (%i)\n", "unknown", status);
+}
+
+/**
+ * Callback, used to swap curve to default when fan mode is changed.
+ */
+static int curve_fan_mode_change(const char *mode);
+
 static ssize_t fan_mode_store(struct device *dev, struct device_attribute *attr,
 			      const char *buf, size_t count)
 {
@@ -3749,6 +3764,12 @@ static ssize_t fan_mode_store(struct device *dev, struct device_attribute *attr,
 		// NULL entries have NULL name
 
 		if (sysfs_streq(conf.fan_mode.modes[i].name, buf)) {
+			const char *mode = conf.fan_mode.modes[i].name;
+
+			result = curve_fan_mode_change(mode);
+			if (result < 0)
+				return result;
+
 			result = ec_write(conf.fan_mode.address,
 					  conf.fan_mode.modes[i].value);
 			if (result < 0)
@@ -3838,6 +3859,340 @@ static struct attribute *msi_root_attrs[] = {
 	NULL
 };
 
+// ============================================================ //
+// Sysfs platform device attributes (fan curves)
+// ============================================================ //
+struct curve_pack {
+	struct msi_ec_fan_curve *curve;
+	u8 *curve_temp;
+	u8 *curve_temp_default;
+	u8 *curve_fan_speed;
+	u8 *curve_fan_speed_default;
+};
+
+static int is_curve_allowed(struct msi_ec_fan_curve curve) {
+	if (
+		curve.speed_start_address == MSI_EC_ADDR_UNSUPP || curve.speed_start_address == 0 || 
+		curve.temperature_start_address == MSI_EC_ADDR_UNSUPP || curve.temperature_start_address == 0 || 
+		curve.entries_count <= 0 || curve.entries_count > CURVE_MAX_ENTRIES 
+	) {
+		return 0;
+	}
+
+	return 1;
+}
+/**
+ * Synchronizes (gets and stores) ec curve to local in-memory curves.
+ */
+static int sync_ec_curve(struct msi_ec_fan_curve curve, u8 *fan_speed_buf, u8 *temperature_buf) {
+	if (!is_curve_allowed(curve)) return -EINVAL;
+
+	for (int i = 0, j = curve.speed_start_address; i < curve.entries_count; i++, j++) {
+		if (ec_read(j, &fan_speed_buf[i])) return -EIO;
+	}
+	for (int i = 0, j = curve.temperature_start_address; i < curve.entries_count - 1; i++, j++) {
+		if (ec_read(j, &temperature_buf[i])) return -EIO;
+	}
+
+	return 0;
+}
+
+/**
+ * Writes curve from buffers to ec.
+ */
+static int push_ec_curve(struct msi_ec_fan_curve curve, const u8 *fan_speed_buf, const u8 *temperature_buf) {
+	if (!is_curve_allowed(curve)) return -EINVAL;
+
+	for (int i = 0, j = curve.speed_start_address; i < curve.entries_count; i++, j++) {
+		if (ec_write(j, fan_speed_buf[i])) return -EIO;
+	}
+	for (int i = 0, j = curve.temperature_start_address; i < curve.entries_count - 1; i++, j++) {
+		if (ec_write(j, temperature_buf[i])) return -EIO;
+	}
+
+	return 0;
+}
+
+/**
+ * A wrapper for sync_ec_curve. Checks ability and safety to overwrite curve buffers.
+ */
+static int sync_ec_curve_safe(struct msi_ec_fan_curve curve, u8 *fan_speed_buf, u8 *temperature_buf) {
+	const char *fan_mode;
+
+	if (curve.apply_strategy == CURVE_APPLY_STRATEGY_RESET_ON_AUTO) {
+		if (fan_mode_get(&fan_mode)) return -ENODATA;
+
+		if (strcmp(fan_mode, FM_ADVANCED_NAME)) return 0;
+	}
+
+	return sync_ec_curve(curve, fan_speed_buf, temperature_buf);
+}
+
+/**
+ * A wrapper for push_ec_curve. Checks ability and safety to write curve.
+ */
+static int push_ec_curve_safe(struct msi_ec_fan_curve curve, const u8 *fan_speed_buf, const u8 *temperature_buf) {
+	const char *fan_mode;
+
+	if (curve.apply_strategy == CURVE_APPLY_STRATEGY_RESET_ON_AUTO) {
+		if (fan_mode_get(&fan_mode)) return -ENODATA;
+
+		if (strcmp(fan_mode, FM_ADVANCED_NAME)) return 0;
+	}
+
+	return push_ec_curve(curve, fan_speed_buf, temperature_buf);
+}
+
+
+
+/**
+ * Curve is represented in format:
+ * s0 t1 s1 t2 s2 t3 s3 ... t(n-1) s(n-1) t(n) s(n)
+ *
+ * Notice that here is no leading temperature as it represents `less_than_t1`
+ */
+
+static ssize_t print_curve(const u8 *fan_speed_buf, const u8 *temperature_buf, int entries, char *buf) {
+	char str[128];
+	int i = 0;
+
+	int sz = 2 * entries - 1;
+	for (int j = 0, sc = 0, tc = 0; j < sz; j++) {
+		if (j % 2 == 0) {
+			i += sprintf(str + i, "%d ", fan_speed_buf[sc++]);
+		} else {
+			i += sprintf(str + i, "%d ", temperature_buf[tc++]);
+		}
+	}
+	str[i - 1] = '\0';
+
+	return sysfs_emit(buf, "%s\n", str);
+}
+
+static ssize_t read_curve(u8 *fan_speed_buf, u8 *temperature_buf, int entries, const char *buf, size_t count) {
+	int sz = 2 * entries - 1;
+	int data[2 * CURVE_MAX_ENTRIES];
+
+	const char *sdata = buf;
+	int offset;
+	for (int i = 0; i < sz; i++) {
+		if (sdata >= buf + count) return -EINVAL;
+		if (sscanf(sdata, "%u%n", &data[i], &offset) != 1)
+			return -EINVAL;
+
+		if (data[i] >= 256) return -EINVAL;
+		sdata += offset;
+	}
+	if (sdata < buf + count && *sdata == '\n') sdata++;
+	if (sdata != buf + count) return -EINVAL;
+
+	u8 temp_speed_buf[CURVE_MAX_ENTRIES];
+	u8 temp_temperature_buf[CURVE_MAX_ENTRIES];
+
+	for (int j = 0, sc = 0, tc = 0; j < sz; j++) {
+		if (j % 2 == 0) {
+			temp_speed_buf[sc++] = (u8)data[j];
+		} else {
+			temp_temperature_buf[tc++] = (u8)data[j];
+		}
+	}
+
+	int late_temp = 0;
+	// Validate buffs.
+	for (int i = 0; i < entries - 1; i++) {
+		if (late_temp >= temp_temperature_buf[i] || temp_temperature_buf[i] > 100) return -EINVAL;
+		late_temp = temp_temperature_buf[i];
+	}
+	for (int i = 0; i < entries; i++) {
+		if (temp_speed_buf[i] > 150) return -EINVAL;
+	}
+
+	for (int i = 0; i < entries; i++) {
+		fan_speed_buf[i] = temp_speed_buf[i];
+		temperature_buf[i] = temp_temperature_buf[i];
+	}
+
+	return count;
+}
+
+static ssize_t curve_show(struct curve_pack curve_data, char *buf) {
+	int status = sync_ec_curve_safe(*curve_data.curve, curve_data.curve_fan_speed, curve_data.curve_temp);
+	if (status < 0) return status;
+
+	return print_curve(curve_data.curve_fan_speed, curve_data.curve_temp, curve_data.curve->entries_count, buf);
+}
+static ssize_t curve_store(struct curve_pack curve_data, const char *buf, size_t count) {
+
+	ssize_t scount = read_curve(curve_data.curve_fan_speed, curve_data.curve_temp, conf.cpu.fan_curve.entries_count, buf, count);
+	if (scount < 0) return scount;
+
+	int status = push_ec_curve_safe(*curve_data.curve, curve_data.curve_fan_speed, curve_data.curve_temp);
+	if (status < 0) return status;
+
+	return scount;
+}
+
+static int curve_init(struct curve_pack curve_data) {
+	if (is_curve_allowed(*curve_data.curve)) {
+		int status = sync_ec_curve(*curve_data.curve, 
+			     curve_data.curve_fan_speed_default, curve_data.curve_temp_default);
+
+		if (status < 0) return status;
+
+		for (int i = 0; i < CURVE_MAX_ENTRIES; i++) {
+			curve_data.curve_fan_speed[i] = curve_data.curve_fan_speed_default[i];
+			curve_data.curve_temp[i] = curve_data.curve_temp_default[i];
+		}
+	}
+
+	return 0;
+}
+
+static int curve_destroy(struct curve_pack curve_data) {
+	if (is_curve_allowed(*curve_data.curve)) {
+		int status = push_ec_curve(*curve_data.curve,
+			curve_data.curve_fan_speed_default, curve_data.curve_temp_default);
+
+		if (status < 0) return status;
+		for (int i = 0; i < CURVE_MAX_ENTRIES; i++) {
+			curve_data.curve_fan_speed[i] = curve_data.curve_fan_speed_default[i];
+			curve_data.curve_temp[i] = curve_data.curve_temp_default[i];
+		}
+	}
+	return 0;
+}
+
+
+
+/**
+ * Used to store curve data.
+ */
+static u8 cpu_curve_temp[CURVE_MAX_ENTRIES];
+static u8 cpu_curve_fan_speed[CURVE_MAX_ENTRIES];
+
+/**
+ * Default settings of curve. Used to backup curve on module exit and fan mode switch 
+ * (to avoid issues on some devices).
+ */
+static u8 cpu_curve_temp_default[CURVE_MAX_ENTRIES];
+static u8 cpu_curve_fan_speed_default[CURVE_MAX_ENTRIES];
+struct curve_pack cpu_curve_package = {
+	.curve = &conf.cpu.fan_curve,
+	.curve_temp = cpu_curve_temp,
+	.curve_fan_speed = cpu_curve_fan_speed,
+	.curve_temp_default = cpu_curve_temp_default,
+	.curve_fan_speed_default = cpu_curve_fan_speed_default
+};
+
+static ssize_t dev_attr_cpu_curve_show(struct device *dev, struct device_attribute *attr, 
+				       char *buf) {
+	return curve_show(cpu_curve_package, buf);
+}
+static ssize_t dev_attr_cpu_curve_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count) {
+	return curve_store(cpu_curve_package, buf, count);
+}
+
+
+static struct device_attribute dev_attr_cpu_curve = {
+	.attr = {
+		.name = "curve",
+		.mode = 0644,
+	},
+	.show = dev_attr_cpu_curve_show,
+	.store = dev_attr_cpu_curve_store,
+};
+
+/**
+ * Used to store curve data.
+ */
+static u8 gpu_curve_temp[CURVE_MAX_ENTRIES];
+static u8 gpu_curve_fan_speed[CURVE_MAX_ENTRIES];
+
+/**
+ * Default settings of curve. Used to backup curve on module exit and fan mode switch 
+ * (to avoid issues on some devices).
+ */
+static u8 gpu_curve_temp_default[CURVE_MAX_ENTRIES];
+static u8 gpu_curve_fan_speed_default[CURVE_MAX_ENTRIES];
+struct curve_pack gpu_curve_package = {
+	.curve = &conf.gpu.fan_curve,
+	.curve_temp = gpu_curve_temp,
+	.curve_fan_speed = gpu_curve_fan_speed,
+	.curve_temp_default = gpu_curve_temp_default,
+	.curve_fan_speed_default = gpu_curve_fan_speed_default
+};
+
+static ssize_t dev_attr_gpu_curve_show(struct device *dev, struct device_attribute *attr, 
+				       char *buf) {
+	return curve_show(gpu_curve_package, buf);
+}
+static ssize_t dev_attr_gpu_curve_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count) {
+	return curve_store(gpu_curve_package, buf, count);
+}
+
+static struct device_attribute dev_attr_gpu_curve = {
+	.attr = {
+		.name = "curve",
+		.mode = 0644,
+	},
+	.show = dev_attr_gpu_curve_show,
+	.store = dev_attr_gpu_curve_store,
+};
+
+const struct {
+	struct curve_pack *cpu_curve;	
+	struct curve_pack *gpu_curve;	
+} all_curves = {
+	.cpu_curve = &cpu_curve_package,
+	.gpu_curve = &gpu_curve_package,
+};
+#define ALL_CURVES_COUNT 2
+
+static int curve_fan_mode_change(const char *mode) {
+	struct curve_pack *all_curves_list[ALL_CURVES_COUNT]= {
+		all_curves.cpu_curve,
+		all_curves.gpu_curve
+	};
+
+	if (!strcmp(mode, FM_ADVANCED_NAME)) {
+		for (int i = 0; i < ALL_CURVES_COUNT; i++) {
+			struct curve_pack curve_data = *all_curves_list[i];
+
+			if (curve_data.curve->apply_strategy == CURVE_APPLY_STRATEGY_RESET_ON_AUTO &&
+				is_curve_allowed(*curve_data.curve)) {
+
+				int status = push_ec_curve(*curve_data.curve, 
+					curve_data.curve_fan_speed, curve_data.curve_temp);
+				if (status < 0) {
+					return status;
+				}
+			}
+
+		}
+
+	} else {
+		for (int i = 0; i < ALL_CURVES_COUNT; i++) {
+			struct curve_pack curve_data = *all_curves_list[i];
+
+			if (curve_data.curve->apply_strategy == CURVE_APPLY_STRATEGY_RESET_ON_AUTO &&
+				is_curve_allowed(*curve_data.curve)) {
+
+				sync_ec_curve_safe(*curve_data.curve, curve_data.curve_fan_speed, curve_data.curve_temp);
+				int status = push_ec_curve(*curve_data.curve, 
+					curve_data.curve_fan_speed_default, curve_data.curve_temp_default);
+				if (status < 0) {
+					return status;
+				}
+			}
+
+		}
+	}
+
+	return 0;
+}
+
 // ============================================================ //
 // Sysfs platform device attributes (cpu)
 // ============================================================ //
@@ -3889,6 +4244,7 @@ static struct device_attribute dev_attr_cpu_realtime_fan_speed = {
 static struct attribute *msi_cpu_attrs[] = {
 	&dev_attr_cpu_realtime_temperature.attr,
 	&dev_attr_cpu_realtime_fan_speed.attr,
+	&dev_attr_cpu_curve.attr,
 	NULL
 };
 
@@ -3943,6 +4299,7 @@ static struct device_attribute dev_attr_gpu_realtime_fan_speed = {
 static struct attribute *msi_gpu_attrs[] = {
 	&dev_attr_gpu_realtime_temperature.attr,
 	&dev_attr_gpu_realtime_fan_speed.attr,
+	&dev_attr_gpu_curve.attr,
 	NULL
 };
 
@@ -4238,6 +4595,8 @@ static const struct attribute_group *msi_platform_groups[] = {
 
 static int __init msi_platform_probe(struct platform_device *pdev)
 {
+	int status;
+
 	if (debug) {
 		int result = sysfs_create_group(&pdev->dev.kobj,
 						&msi_debug_group);
@@ -4381,6 +4740,10 @@ static void __exit msi_ec_exit(void)
 			battery_hook_unregister(&battery_hook);
 	}
 
+	// Destroy curve and load default settings.
+	curve_destroy(cpu_curve_package);
+	curve_destroy(gpu_curve_package);
+
 	platform_device_unregister(msi_platform_device);
 	platform_driver_unregister(&msi_platform_driver);
 
-- 
2.39.1


From b2f133cfc1ce8e3b6d047ed4c18510dc9b30389c Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 00:14:32 +0800
Subject: [PATCH 03/10] Add hwmon support for fan speed and temperature
 monitoring

---
 Makefile |   2 +-
 msi-ec.c | 161 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 162 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index bffcbd4..a8f09af 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,4 @@
-VERSION         := 0.08
+VERSION         := 0.10
 DKMS_ROOT_PATH  := /usr/src/msi_ec-$(VERSION)
 TARGET ?= $(shell uname -r)
 
diff --git a/msi-ec.c b/msi-ec.c
index 3c0a25a..b43bae6 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -39,10 +39,23 @@
 #include <linux/version.h>
 #include <linux/rtc.h>
 #include <linux/string_choices.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 
 static DEFINE_MUTEX(ec_set_by_mask_mutex);
 static DEFINE_MUTEX(ec_unset_by_mask_mutex);
 static DEFINE_MUTEX(ec_set_bit_mutex);
+// ============================================================ //
+// Hwmon device data
+// ============================================================ //
+
+struct msi_ec_hwmon_data {
+	struct device *dev;
+	const char *name;
+};
+
+static struct msi_ec_hwmon_data *hwmon_data;
+static struct device *hwmon_dev;
 
 #define SM_ECO_NAME		"eco"
 #define SM_COMFORT_NAME		"comfort"
@@ -4675,6 +4688,133 @@ static int __init load_configuration(void)
 	return -EOPNOTSUPP;
 }
 
+// ============================================================ //
+// Hwmon functions
+// ============================================================ //
+
+static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+                                       u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_temp:
+		if (attr == hwmon_temp_input && 
+		    ((channel == 0 && conf.cpu.rt_temp_address != MSI_EC_ADDR_UNSUPP) || 
+		     (channel == 1 && conf.gpu.rt_temp_address != MSI_EC_ADDR_UNSUPP)))
+			return 0444;
+		break;
+	case hwmon_fan:
+		if (attr == hwmon_fan_input &&
+		    ((channel == 0 && conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) ||
+		     (channel == 1 && conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP)))
+			return 0444;
+		break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+
+static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+                             u32 attr, int channel, long *val)
+{
+	u8 value;
+	u8 high_byte, low_byte;
+	u16 fan_value;
+	int result;
+	
+	switch (type) {
+	case hwmon_temp:
+		if (attr == hwmon_temp_input) {
+			if (channel == 0 && conf.cpu.rt_temp_address != MSI_EC_ADDR_UNSUPP) {
+				result = ec_read_seq(conf.cpu.rt_temp_address, &value, 1);
+				if (result < 0)
+					return result;
+				*val = value * 1000; // Convert to millidegree Celsius
+				return 0;
+			} else if (channel == 1 && conf.gpu.rt_temp_address != MSI_EC_ADDR_UNSUPP) {
+				result = ec_read_seq(conf.gpu.rt_temp_address, &value, 1);
+				if (result < 0)
+					return result;
+				*val = value * 1000; // Convert to millidegree Celsius
+				return 0;
+			}
+		}
+		break;
+	case hwmon_fan:
+		if (attr == hwmon_fan_input) {
+			if (channel == 0) { // CPU fan
+				// Read high byte (0xC8)
+				result = ec_read_seq(0xC8, &high_byte, 1);
+				if (result < 0)
+					return result;
+				
+				// Read low byte (0xC9)
+				result = ec_read_seq(0xC9, &low_byte, 1);
+				if (result < 0)
+					return result;
+				
+				// Combine into complete fan speed value
+				fan_value = (high_byte << 8) | low_byte;
+				
+				// If value is 0, fan might be stopped
+				if (fan_value == 0)
+					*val = 0;
+				else
+					*val = 478000 / fan_value; // Apply formula RPM = 478000 / value
+				
+				return 0;
+			} else if (channel == 1) { // GPU fan
+				// Read high byte (0xCA)
+				result = ec_read_seq(0xCA, &high_byte, 1);
+				if (result < 0)
+					return result;
+				
+				// Read low byte (0xCB)
+				result = ec_read_seq(0xCB, &low_byte, 1);
+				if (result < 0)
+					return result;
+				
+				// Combine into complete fan speed value
+				fan_value = (high_byte << 8) | low_byte;
+				
+				// If value is 0, fan might be stopped
+				if (fan_value == 0)
+					*val = 0;
+				else
+					*val = 478000 / fan_value; // Apply formula RPM = 478000 / value
+				
+				return 0;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops msi_ec_hwmon_ops = {
+	.is_visible = msi_ec_hwmon_is_visible,
+	.read = msi_ec_hwmon_read,
+};
+
+static const struct hwmon_channel_info *msi_ec_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(temp,
+                  HWMON_T_INPUT,  // CPU temperature
+                  HWMON_T_INPUT), // GPU temperature
+	HWMON_CHANNEL_INFO(fan,
+                  HWMON_F_INPUT,  // CPU fan
+                  HWMON_F_INPUT), // GPU fan
+	NULL
+};
+
+static const struct hwmon_chip_info msi_ec_hwmon_chip_info = {
+	.ops = &msi_ec_hwmon_ops,
+	.info = msi_ec_hwmon_info,
+};
+
 static int __init msi_ec_init(void)
 {
 	int result;
@@ -4720,6 +4860,23 @@ static int __init msi_ec_init(void)
 		led_classdev_register(&msi_platform_device->dev,
 				      &msiacpi_led_kbdlight);
 
+	// register hwmon device
+	hwmon_data = devm_kzalloc(&msi_platform_device->dev, sizeof(*hwmon_data), GFP_KERNEL);
+	if (!hwmon_data)
+		return -ENOMEM;
+	
+	hwmon_data->dev = &msi_platform_device->dev;
+	hwmon_data->name = "msi_ec";
+	
+	dev_set_drvdata(&msi_platform_device->dev, hwmon_data);
+	
+	hwmon_dev = hwmon_device_register_with_info(&msi_platform_device->dev,
+						      hwmon_data->name, hwmon_data,
+						      &msi_ec_hwmon_chip_info, NULL);
+	
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
 	return 0;
 }
 
@@ -4740,6 +4897,10 @@ static void __exit msi_ec_exit(void)
 			battery_hook_unregister(&battery_hook);
 	}
 
+	// unregister hwmon device
+	if (hwmon_dev)
+		hwmon_device_unregister(hwmon_dev);
+
 	// Destroy curve and load default settings.
 	curve_destroy(cpu_curve_package);
 	curve_destroy(gpu_curve_package);
-- 
2.39.1


From 68e68e2ace5f47f8f6463f010ca50ee4a68cd5d4 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 00:33:14 +0800
Subject: [PATCH 04/10] Add fan label support to hwmon interface

---
 msi-ec.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/msi-ec.c b/msi-ec.c
index b43bae6..21c2b37 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -4707,6 +4707,10 @@ static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types
 		    ((channel == 0 && conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) ||
 		     (channel == 1 && conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP)))
 			return 0444;
+		else if (attr == hwmon_fan_label &&
+			 ((channel == 0 && conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) ||
+			  (channel == 1 && conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP)))
+			return 0444;
 		break;
 	default:
 		break;
@@ -4715,6 +4719,28 @@ static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types
 	return 0;
 }
 
+static int msi_ec_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
+                                   u32 attr, int channel, const char **str)
+{
+    switch (type) {
+    case hwmon_fan:
+        if (attr == hwmon_fan_label) {
+            if (channel == 0) {
+                *str = "cpu_fan";
+                return 0;
+            } else if (channel == 1) {
+                *str = "gpu_fan";
+                return 0;
+            }
+        }
+        break;
+    default:
+        break;
+    }
+    
+    return -EINVAL;
+}
+
 static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
                              u32 attr, int channel, long *val)
 {
@@ -4798,6 +4824,7 @@ static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 static const struct hwmon_ops msi_ec_hwmon_ops = {
 	.is_visible = msi_ec_hwmon_is_visible,
 	.read = msi_ec_hwmon_read,
+	.read_string = msi_ec_hwmon_read_string,
 };
 
 static const struct hwmon_channel_info *msi_ec_hwmon_info[] = {
@@ -4805,8 +4832,8 @@ static const struct hwmon_channel_info *msi_ec_hwmon_info[] = {
                   HWMON_T_INPUT,  // CPU temperature
                   HWMON_T_INPUT), // GPU temperature
 	HWMON_CHANNEL_INFO(fan,
-                  HWMON_F_INPUT,  // CPU fan
-                  HWMON_F_INPUT), // GPU fan
+                  HWMON_F_INPUT | HWMON_F_LABEL,  // CPU fan
+                  HWMON_F_INPUT | HWMON_F_LABEL), // GPU fan
 	NULL
 };
 
-- 
2.39.1


From 386da7f3e2cc291cbd1b7440cf0023df2573719a Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 03:17:25 +0800
Subject: [PATCH 05/10] hwmon: Implement fan PWM control functionality

---
 msi-ec.c | 234 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 226 insertions(+), 8 deletions(-)

diff --git a/msi-ec.c b/msi-ec.c
index 21c2b37..924a3e1 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -4692,6 +4692,23 @@ static int __init load_configuration(void)
 // Hwmon functions
 // ============================================================ //
 
+static ssize_t pwm_enable_available_show(struct device *dev, struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR_RO(pwm_enable_available);
+
+// Check if a specific fan mode is available in the configuration
+static bool fan_mode_is_available(const char *mode)
+{
+    int i;
+    
+    for (i = 0; i < ARRAY_SIZE(conf.fan_mode.modes); i++) {
+        if (strcmp(conf.fan_mode.modes[i].name, mode) == 0)
+            return true;
+    }
+    
+    return false;
+}
+
 static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
                                        u32 attr, int channel)
 {
@@ -4712,6 +4729,12 @@ static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types
 			  (channel == 1 && conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP)))
 			return 0444;
 		break;
+	case hwmon_pwm:
+		if (attr == hwmon_pwm_enable &&
+		    ((channel == 0 && conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) ||
+		     (channel == 1 && conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP)))
+			return 0644;
+		break;
 	default:
 		break;
 	}
@@ -4719,6 +4742,108 @@ static umode_t msi_ec_hwmon_is_visible(const void *data, enum hwmon_sensor_types
 	return 0;
 }
 
+// Helper function to set fan mode using mode name
+static int set_fan_mode(const char *mode)
+{
+    int result;
+
+    for (int i = 0; i < ARRAY_SIZE(conf.fan_mode.modes); i++) {
+        // NULL entries have NULL name
+        if (conf.fan_mode.modes[i].name && 
+            strcmp(conf.fan_mode.modes[i].name, mode) == 0) {
+            
+            result = curve_fan_mode_change(mode);
+            if (result < 0)
+                return result;
+
+            result = ec_write(conf.fan_mode.address,
+                              conf.fan_mode.modes[i].value);
+            if (result < 0)
+                return result;
+
+            return 0;
+        }
+    }
+    
+    return -EINVAL; // Invalid mode
+}
+
+// Helper function to set cooler boost mode
+static int set_cooler_boost(bool enable)
+{
+    int result;
+    
+    if (conf.cooler_boost.address == MSI_EC_ADDR_UNSUPP)
+        return -EINVAL;
+    
+    result = ec_set_bit(conf.cooler_boost.address, conf.cooler_boost.bit, enable);
+    if (result < 0)
+        return result;
+
+    return 0;
+}
+
+static int msi_ec_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+                             u32 attr, int channel, long val)
+{
+    int result = 0;
+    
+    switch (type) {
+    case hwmon_fan:
+		break;
+	case hwmon_pwm:
+        if (attr == hwmon_pwm_enable) {
+            if (channel == 0 || channel == 1) { // CPU and GPU fans share mode control
+                // Change fan mode based on val
+                switch (val) {
+                case 1: // Manual mode - Advanced
+                    result = set_cooler_boost(false);
+                    if (fan_mode_is_available(FM_ADVANCED_NAME))
+                        result = set_fan_mode(FM_ADVANCED_NAME);
+                    else
+                        return -EINVAL;
+                    break;
+                case 2: // Automatic mode - Auto
+                    result = set_cooler_boost(false);
+                    if (fan_mode_is_available(FM_AUTO_NAME))
+                        result = set_fan_mode(FM_AUTO_NAME);
+                    else
+                        return -EINVAL;
+                    break;
+                case 3: // Full speed mode - Cooler Boost
+                    if (conf.cooler_boost.address != MSI_EC_ADDR_UNSUPP)
+                        result = set_cooler_boost(true);
+                    else
+                        return -EINVAL;
+                    break;
+                case 4: // Silent mode
+                    result = set_cooler_boost(false);
+                    if (fan_mode_is_available(FM_SILENT_NAME))
+                        result = set_fan_mode(FM_SILENT_NAME);
+                    else
+                        return -EINVAL;
+                    break;
+                case 5: // Basic mode
+                    result = set_cooler_boost(false);
+                    if (fan_mode_is_available(FM_BASIC_NAME))
+                        result = set_fan_mode(FM_BASIC_NAME);
+                    else
+                        return -EINVAL;
+                    break;
+                default:
+                    return -EINVAL;
+                }
+            }
+            return result;
+        }
+        break;
+    default:
+        break;
+    }
+    
+    return -EINVAL;
+}
+
 static int msi_ec_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
                                    u32 attr, int channel, const char **str)
 {
@@ -4787,7 +4912,7 @@ static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 				if (fan_value == 0)
 					*val = 0;
 				else
-					*val = 478000 / fan_value; // Apply formula RPM = 478000 / value
+					*val = 480000 / fan_value; // Apply formula RPM = 480000 / value
 				
 				return 0;
 			} else if (channel == 1) { // GPU fan
@@ -4808,12 +4933,47 @@ static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 				if (fan_value == 0)
 					*val = 0;
 				else
-					*val = 478000 / fan_value; // Apply formula RPM = 478000 / value
+					*val = 480000 / fan_value; // Apply formula RPM = 480000 / value
 				
 				return 0;
 			}
 		}
 		break;
+	case hwmon_pwm:
+		if (attr == hwmon_pwm_enable) {
+			// CPU and GPU fans share mode control, so return the same value for both channels
+    		if (channel == 0 || channel == 1) {
+				int result;
+				bool cooler_boost_enabled = false;
+				const char *mode_name = NULL;
+    		    if (conf.cooler_boost.address != MSI_EC_ADDR_UNSUPP) {
+					result = ec_check_bit(conf.cooler_boost.address, conf.cooler_boost.bit, &cooler_boost_enabled);
+					if (result < 0)
+						return result;
+				}
+    		    if (cooler_boost_enabled) {
+					*val = 3; // Full speed mode
+					return 0;
+				} else {
+					result = fan_mode_get(&mode_name);
+					if (result < 0)
+						return result;
+					
+					if (strcmp(mode_name, FM_ADVANCED_NAME) == 0)
+						*val = 1; // Manual mode
+					else if (strcmp(mode_name, FM_AUTO_NAME) == 0)
+						*val = 2; // Automatic mode
+					else if (strcmp(mode_name, FM_SILENT_NAME) == 0)
+						*val = 4; // Silent mode
+					else if (strcmp(mode_name, FM_BASIC_NAME) == 0)
+						*val = 5; // Basic mode
+					else
+						*val = 0; // Unknown mode
+					return 0;
+				}
+			}
+		}
+		break;
 	default:
 		break;
 	}
@@ -4821,10 +4981,44 @@ static int msi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 	return -EOPNOTSUPP;
 }
 
+static ssize_t pwm_enable_available_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int len = 0;
+    const char *mode_names[6] = {NULL}; // Index corresponds to mode value, 0 is not used
+    
+    // First collect all mode names
+    for (int i = 0; conf.fan_mode.modes[i].name; i++) {
+        if (strcmp(conf.fan_mode.modes[i].name, FM_ADVANCED_NAME) == 0)
+            mode_names[1] = conf.fan_mode.modes[i].name;  // Manual mode
+        else if (strcmp(conf.fan_mode.modes[i].name, FM_AUTO_NAME) == 0)
+            mode_names[2] = conf.fan_mode.modes[i].name;  // Auto mode
+        else if (strcmp(conf.fan_mode.modes[i].name, FM_SILENT_NAME) == 0)
+            mode_names[4] = conf.fan_mode.modes[i].name;  // Silent mode
+        else if (strcmp(conf.fan_mode.modes[i].name, FM_BASIC_NAME) == 0)
+            mode_names[5] = conf.fan_mode.modes[i].name;  // Basic mode
+    }
+    
+    // Add Cooler Boost (if supported)
+    if (conf.cooler_boost.address != MSI_EC_ADDR_UNSUPP) {
+        mode_names[3] = "full";
+    }
+    
+    // Output in order
+    for (int i = 1; i <= 5; i++) {
+        if (mode_names[i]) {
+            len += scnprintf(buf + len, PAGE_SIZE - len, 
+                          "%d: %s\n", i, mode_names[i]);
+        }
+    }
+    
+    return len;
+}
+
 static const struct hwmon_ops msi_ec_hwmon_ops = {
 	.is_visible = msi_ec_hwmon_is_visible,
 	.read = msi_ec_hwmon_read,
 	.read_string = msi_ec_hwmon_read_string,
+	.write = msi_ec_hwmon_write,
 };
 
 static const struct hwmon_channel_info *msi_ec_hwmon_info[] = {
@@ -4832,8 +5026,11 @@ static const struct hwmon_channel_info *msi_ec_hwmon_info[] = {
                   HWMON_T_INPUT,  // CPU temperature
                   HWMON_T_INPUT), // GPU temperature
 	HWMON_CHANNEL_INFO(fan,
-                  HWMON_F_INPUT | HWMON_F_LABEL,  // CPU fan
-                  HWMON_F_INPUT | HWMON_F_LABEL), // GPU fan
+				HWMON_F_INPUT | HWMON_F_LABEL,  // CPU fan
+				HWMON_F_INPUT | HWMON_F_LABEL), // GPU fan
+	HWMON_CHANNEL_INFO(pwm,
+				HWMON_PWM_ENABLE,  // CPU fan PWM
+				HWMON_PWM_ENABLE), // GPU fan PWM
 	NULL
 };
 
@@ -4842,6 +5039,20 @@ static const struct hwmon_chip_info msi_ec_hwmon_chip_info = {
 	.info = msi_ec_hwmon_info,
 };
 
+static struct attribute *msi_ec_hwmon_attrs[] = {
+    &dev_attr_pwm_enable_available.attr,
+    NULL
+};
+
+static const struct attribute_group msi_ec_hwmon_group = {
+    .attrs = msi_ec_hwmon_attrs,
+};
+
+static const struct attribute_group *msi_ec_hwmon_groups[] = {
+    &msi_ec_hwmon_group,
+    NULL
+};
+
 static int __init msi_ec_init(void)
 {
 	int result;
@@ -4887,22 +5098,29 @@ static int __init msi_ec_init(void)
 		led_classdev_register(&msi_platform_device->dev,
 				      &msiacpi_led_kbdlight);
 
+	pr_info("msi-ec: Registering hwmon device\n");
+
 	// register hwmon device
 	hwmon_data = devm_kzalloc(&msi_platform_device->dev, sizeof(*hwmon_data), GFP_KERNEL);
 	if (!hwmon_data)
 		return -ENOMEM;
 	
 	hwmon_data->dev = &msi_platform_device->dev;
-	hwmon_data->name = "msi_ec";
+	hwmon_data->name = MSI_EC_DRIVER_NAME;
 	
 	dev_set_drvdata(&msi_platform_device->dev, hwmon_data);
 	
 	hwmon_dev = hwmon_device_register_with_info(&msi_platform_device->dev,
 						      hwmon_data->name, hwmon_data,
-						      &msi_ec_hwmon_chip_info, NULL);
+						      &msi_ec_hwmon_chip_info, 
+						      msi_ec_hwmon_groups);
 	
-	if (IS_ERR(hwmon_dev))
-		return PTR_ERR(hwmon_dev);
+	if (IS_ERR(hwmon_dev)) {
+		int err = PTR_ERR(hwmon_dev);
+		pr_err("msi-ec: hwmon device register failed with error %d\n", err);
+		return err;
+	}
+	pr_info("msi-ec: hwmon device registered successfully\n");
 
 	return 0;
 }
-- 
2.39.1


From 096517b323e6925a97a5a43602631bfec27e9e3f Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 12:58:47 +0800
Subject: [PATCH 06/10] hwmon: Implement fan PWM curve control functionality

---
 Makefile                  |   2 +-
 ec_memory_configuration.h |   9 +
 msi-ec.c                  | 423 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 432 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index a8f09af..777339c 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,4 @@
-VERSION         := 0.10
+VERSION         := 0.11
 DKMS_ROOT_PATH  := /usr/src/msi_ec-$(VERSION)
 TARGET ?= $(shell uname -r)
 
diff --git a/ec_memory_configuration.h b/ec_memory_configuration.h
index 8e59048..f6b57a4 100644
--- a/ec_memory_configuration.h
+++ b/ec_memory_configuration.h
@@ -2,6 +2,7 @@
 #define __MSI_EC_REGISTERS_CONFIG__
 
 #include <linux/types.h>
+#include <linux/device.h>
 
 #define MSI_EC_DRIVER_NAME "msi-ec"
 
@@ -126,4 +127,12 @@ struct msi_ec_conf {
 	struct msi_ec_kbd_bl_conf         kbd_bl;
 };
 
+// Struct to hold curve point attribute information
+struct msi_ec_curve_attr {
+    struct device_attribute dev_attr;
+    int fan;        // Fan index (0=CPU, 1=GPU)
+    int point;      // Curve point index (1-based)
+    int is_pwm;     // 1=PWM, 0=temperature
+};
+
 #endif // __MSI_EC_REGISTERS_CONFIG__
diff --git a/msi-ec.c b/msi-ec.c
index 924a3e1..fc8143f 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -3151,6 +3151,10 @@ static struct msi_ec_conf conf; // current configuration
 
 static bool charge_control_supported = false;
 
+static bool fan_mode_is_available(const char *mode);
+static int create_fan_curve_attrs(struct device *dev);
+static void remove_fan_curve_attrs(struct device *dev);
+
 static char *firmware = NULL;
 module_param(firmware, charp, 0);
 MODULE_PARM_DESC(firmware, "Load a configuration for a specified firmware version");
@@ -4052,6 +4056,18 @@ static int curve_init(struct curve_pack curve_data) {
 
 		if (status < 0) return status;
 
+		pr_info("msi-ec: Initialized curve with %d entries (addr: speed=%d, temp=%d)\n", 
+                curve_data.curve->entries_count,
+                curve_data.curve->speed_start_address,
+                curve_data.curve->temperature_start_address);
+
+        for (int i = 0; i < curve_data.curve->entries_count; i++) {
+            pr_info("msi-ec:   Point %d: Fan speed = %d%%, Temp = %d°C\n", 
+                    i + 1, 
+                    curve_data.curve_fan_speed_default[i],
+                    i < curve_data.curve->entries_count - 1 ? curve_data.curve_temp_default[i] : 0);
+        }
+
 		for (int i = 0; i < CURVE_MAX_ENTRIES; i++) {
 			curve_data.curve_fan_speed[i] = curve_data.curve_fan_speed_default[i];
 			curve_data.curve_temp[i] = curve_data.curve_temp_default[i];
@@ -4063,6 +4079,17 @@ static int curve_init(struct curve_pack curve_data) {
 
 static int curve_destroy(struct curve_pack curve_data) {
 	if (is_curve_allowed(*curve_data.curve)) {
+		pr_info("msi-ec: Destroying curve with %d entries (addr: speed=%d, temp=%d)\n", 
+                curve_data.curve->entries_count,
+                curve_data.curve->speed_start_address,
+                curve_data.curve->temperature_start_address);
+        
+        for (int i = 0; i < curve_data.curve->entries_count; i++) {
+            pr_info("msi-ec:   Point %d: Fan speed = %d%%, Temp = %d°C\n", 
+                    i + 1, 
+                    curve_data.curve_fan_speed_default[i],
+                    i < curve_data.curve->entries_count - 1 ? curve_data.curve_temp_default[i] : 0);
+        }
 		int status = push_ec_curve(*curve_data.curve,
 			curve_data.curve_fan_speed_default, curve_data.curve_temp_default);
 
@@ -4617,6 +4644,12 @@ static int __init msi_platform_probe(struct platform_device *pdev)
 			return result;
 	}
 
+	status = curve_init(cpu_curve_package);
+	if (status < 0) return status;
+
+	status = curve_init(gpu_curve_package);
+	if (status < 0) return status;
+
 	return 0;
 }
 
@@ -4628,6 +4661,11 @@ static int msi_platform_remove(struct platform_device *pdev)
 {
 	if (debug)
 		sysfs_remove_group(&pdev->dev.kobj, &msi_debug_group);
+	
+	// Remove fan curve attributes
+    if (hwmon_dev) {
+        remove_fan_curve_attrs(hwmon_dev);
+    }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0))
 	return 0;
@@ -4689,13 +4727,373 @@ static int __init load_configuration(void)
 }
 
 // ============================================================ //
-// Hwmon functions
+// Hwmon functions (curve)
 // ============================================================ //
 
 static ssize_t pwm_enable_available_show(struct device *dev, struct device_attribute *attr, char *buf);
 
 static DEVICE_ATTR_RO(pwm_enable_available);
 
+// Array to hold dynamically created attributes
+static struct msi_ec_curve_attr *curve_attrs;
+static int curve_attrs_count;
+
+// Forward declarations
+static ssize_t curve_attr_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t curve_attr_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+// Fan curve points count attributes
+static ssize_t pwm1_auto_points_count_show(struct device *dev, 
+                                         struct device_attribute *attr,
+                                         char *buf)
+{
+    return sysfs_emit(buf, "%d\n", conf.cpu.fan_curve.entries_count);
+}
+
+static ssize_t pwm2_auto_points_count_show(struct device *dev, 
+                                         struct device_attribute *attr,
+                                         char *buf)
+{
+    return sysfs_emit(buf, "%d\n", conf.gpu.fan_curve.entries_count);
+}
+
+static DEVICE_ATTR_RO(pwm1_auto_points_count);
+static DEVICE_ATTR_RO(pwm2_auto_points_count);
+
+// Common show function for all curve point attributes
+static ssize_t curve_attr_show(struct device *dev, 
+                              struct device_attribute *attr,
+                              char *buf)
+{
+    struct msi_ec_curve_attr *curve_attr = 
+        container_of(attr, struct msi_ec_curve_attr, dev_attr);
+    int fan = curve_attr->fan;
+    int point = curve_attr->point;
+    int is_pwm = curve_attr->is_pwm;
+    u8 value;
+    int ret;
+    u16 address;
+
+	pr_debug("msi-ec: curve_attr_show - fan=%d, point=%d, is_pwm=%d\n", 
+             fan, point, is_pwm);
+    
+    // Select proper address based on fan, point and type (PWM or temp)
+    if (fan == 0) { // CPU fan
+        if (is_pwm) {
+            // Make sure point is within range
+            if (point < 1 || point > conf.cpu.fan_curve.entries_count) {
+				pr_debug("msi-ec: Invalid CPU PWM point: %d, max allowed: %d\n", 
+                         point, conf.cpu.fan_curve.entries_count);
+				return -EINVAL;
+			}
+                
+            address = conf.cpu.fan_curve.speed_start_address + (point - 1);
+			pr_debug("msi-ec: Reading CPU PWM from address: 0x%04x\n", address);
+        } else {
+            // Last point has no temperature value
+            if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
+				pr_debug("msi-ec: Invalid CPU temperature point: %d, max allowed: %d\n", 
+                         point, conf.cpu.fan_curve.entries_count);
+				return -EINVAL;
+			}
+                
+            address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
+        }
+    } else { // GPU fan
+        if (is_pwm) {
+            if (point < 1 || point > conf.gpu.fan_curve.entries_count)
+                return -EINVAL;
+                
+            address = conf.gpu.fan_curve.speed_start_address + (point - 1);
+        } else {
+            if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
+                return -EINVAL;
+                
+            address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
+        }
+    }
+    
+    // Read value from EC
+    ret = ec_read(address, &value);
+    if (ret < 0) {
+		pr_debug("msi-ec: Failed to read EC value from address: 0x%04x\n", address);
+		return ret;
+	}
+	pr_debug("msi-ec: Read EC value from address: 0x%04x, value: %u\n", address, value);
+    
+    return sysfs_emit(buf, "%u\n", value);
+}
+
+// Common store function for all curve point attributes
+static ssize_t curve_attr_store(struct device *dev,
+                               struct device_attribute *attr,
+                               const char *buf, size_t count)
+{
+    struct msi_ec_curve_attr *curve_attr = 
+        container_of(attr, struct msi_ec_curve_attr, dev_attr);
+    int fan = curve_attr->fan;
+    int point = curve_attr->point;
+    int is_pwm = curve_attr->is_pwm;
+    unsigned long val;
+    int ret;
+    u16 address;
+
+	pr_debug("msi-ec: curve_attr_store - fan=%d, point=%d, is_pwm=%d\n", 
+             fan, point, is_pwm);
+    
+    // Parse value from user
+    ret = kstrtoul(buf, 10, &val);
+    if (ret < 0) {
+		pr_debug("msi-ec: Failed to parse value from user\n");
+		return ret;
+	}
+    
+    // Select proper address based on fan, point and type (PWM or temp)
+    if (fan == 0) { // CPU fan
+        if (is_pwm) {
+            // Make sure point is within range
+            if (point < 1 || point > conf.cpu.fan_curve.entries_count) {
+				pr_debug("msi-ec: Invalid CPU PWM point: %d, max allowed: %d\n", 
+				         point, conf.cpu.fan_curve.entries_count);
+				return -EINVAL;
+			}
+                
+            // Validate PWM value (0-255)
+            if (val > 255)
+                return -EINVAL;
+            
+            address = conf.cpu.fan_curve.speed_start_address + (point - 1);
+			pr_debug("msi-ec: Writing CPU PWM to address: 0x%04x, value: %lu\n", address, val);
+        } else {
+            // Last point has no temperature value
+            if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
+				pr_debug("msi-ec: Invalid CPU temperature point: %d, max allowed: %d\n", 
+						 point, conf.cpu.fan_curve.entries_count);
+				return -EINVAL;
+			}
+                
+            // Validate temperature value (0-100°C)
+            if (val > 100)
+                return -EINVAL;
+                
+            address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
+			pr_debug("msi-ec: Writing CPU temperature to address: 0x%04x, value: %lu\n", address, val);
+        }
+    } else { // GPU fan
+        // Similar validation for GPU fan...
+        if (is_pwm) {
+            if (point < 1 || point > conf.gpu.fan_curve.entries_count)
+                return -EINVAL;
+                
+            if (val > 255)
+                return -EINVAL;
+                
+            address = conf.gpu.fan_curve.speed_start_address + (point - 1);
+        } else {
+            if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
+                return -EINVAL;
+                
+            if (val > 100)
+                return -EINVAL;
+                
+            address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
+        }
+    }
+    
+    // Write value to EC
+    ret = ec_write(address, val);
+    if (ret < 0) {
+		pr_debug("msi-ec: Failed to write EC value to address: 0x%04x\n", address);
+		return ret;
+	}
+    
+    return count;
+}
+
+// Create fan curve attributes based on configuration
+static int create_fan_curve_attrs(struct device *dev)
+{
+    int i, idx = 0;
+    int cpu_points = conf.cpu.fan_curve.entries_count;
+    int gpu_points = conf.gpu.fan_curve.entries_count;
+    char name[32];
+    int ret;
+
+	pr_debug("msi-ec: create_fan_curve_attrs - CPU points: %d, GPU points: %d\n", 
+			 cpu_points, gpu_points);
+    
+    // Calculate total number of attributes to create
+    // CPU: PWM for all points + temp for all except last + points count
+    // GPU: Same structure
+    curve_attrs_count = cpu_points + (cpu_points - 1) + 
+                       gpu_points + (gpu_points - 1) + 2;
+    
+    // Allocate memory for attributes
+    curve_attrs = kzalloc(sizeof(*curve_attrs) * curve_attrs_count, GFP_KERNEL);
+    if (!curve_attrs) {
+		pr_debug("msi-ec: Failed to allocate memory for curve attributes\n");
+		return -ENOMEM;
+	}
+	
+    // Create attributes for CPU fan curve points
+    for (i = 1; i <= cpu_points; i++) {
+        // PWM attributes
+        snprintf(name, sizeof(name), "pwm1_auto_point%d_pwm", i);
+        
+        curve_attrs[idx].fan = 0;  // CPU
+        curve_attrs[idx].point = i;
+        curve_attrs[idx].is_pwm = 1;
+        
+        curve_attrs[idx].dev_attr.attr.name = 
+            kstrdup(name, GFP_KERNEL);
+        if (!curve_attrs[idx].dev_attr.attr.name) {
+            ret = -ENOMEM;
+            goto cleanup;
+        }
+        
+        curve_attrs[idx].dev_attr.attr.mode = 0644;
+        curve_attrs[idx].dev_attr.show = curve_attr_show;
+        curve_attrs[idx].dev_attr.store = curve_attr_store;
+        
+        ret = device_create_file(dev, &curve_attrs[idx].dev_attr);
+        if (ret < 0)
+            goto cleanup;
+            
+        idx++;
+        
+        // Temperature attributes (except for last point)
+        if (i < cpu_points) {
+            snprintf(name, sizeof(name), "pwm1_auto_point%d_temp", i);
+            
+            curve_attrs[idx].fan = 0;  // CPU
+            curve_attrs[idx].point = i;
+            curve_attrs[idx].is_pwm = 0;
+            
+            curve_attrs[idx].dev_attr.attr.name = 
+                kstrdup(name, GFP_KERNEL);
+            if (!curve_attrs[idx].dev_attr.attr.name) {
+                ret = -ENOMEM;
+                goto cleanup;
+            }
+            
+            curve_attrs[idx].dev_attr.attr.mode = 0644;
+            curve_attrs[idx].dev_attr.show = curve_attr_show;
+            curve_attrs[idx].dev_attr.store = curve_attr_store;
+            
+            ret = device_create_file(dev, &curve_attrs[idx].dev_attr);
+            if (ret < 0)
+                goto cleanup;
+                
+            idx++;
+        }
+    }
+    
+    // Similarly create attributes for GPU fan curve points
+    for (i = 1; i <= gpu_points; i++) {
+        // PWM attributes
+        snprintf(name, sizeof(name), "pwm2_auto_point%d_pwm", i);
+        
+        curve_attrs[idx].fan = 1;  // GPU
+        curve_attrs[idx].point = i;
+        curve_attrs[idx].is_pwm = 1;
+        
+        curve_attrs[idx].dev_attr.attr.name = 
+            kstrdup(name, GFP_KERNEL);
+        if (!curve_attrs[idx].dev_attr.attr.name) {
+            ret = -ENOMEM;
+            goto cleanup;
+        }
+        
+        curve_attrs[idx].dev_attr.attr.mode = 0644;
+        curve_attrs[idx].dev_attr.show = curve_attr_show;
+        curve_attrs[idx].dev_attr.store = curve_attr_store;
+        
+        ret = device_create_file(dev, &curve_attrs[idx].dev_attr);
+        if (ret < 0)
+            goto cleanup;
+            
+        idx++;
+        
+        // Temperature attributes (except for last point)
+        if (i < gpu_points) {
+            snprintf(name, sizeof(name), "pwm2_auto_point%d_temp", i);
+            
+            curve_attrs[idx].fan = 1;  // GPU
+            curve_attrs[idx].point = i;
+            curve_attrs[idx].is_pwm = 0;
+            
+            curve_attrs[idx].dev_attr.attr.name = 
+                kstrdup(name, GFP_KERNEL);
+            if (!curve_attrs[idx].dev_attr.attr.name) {
+                ret = -ENOMEM;
+                goto cleanup;
+            }
+            
+            curve_attrs[idx].dev_attr.attr.mode = 0644;
+            curve_attrs[idx].dev_attr.show = curve_attr_show;
+            curve_attrs[idx].dev_attr.store = curve_attr_store;
+            
+            ret = device_create_file(dev, &curve_attrs[idx].dev_attr);
+            if (ret < 0)
+                goto cleanup;
+                
+            idx++;
+        }
+    }
+    
+    // Create points count attributes
+    ret = device_create_file(dev, &dev_attr_pwm1_auto_points_count);
+    if (ret < 0)
+        goto cleanup;
+        
+    ret = device_create_file(dev, &dev_attr_pwm2_auto_points_count);
+    if (ret < 0) {
+        device_remove_file(dev, &dev_attr_pwm1_auto_points_count);
+        goto cleanup;
+    }
+    
+    return 0;
+    
+cleanup:
+    // Remove already created attributes
+    for (i = 0; i < idx; i++) {
+		if (curve_attrs[i].dev_attr.attr.name) {
+			kfree(curve_attrs[i].dev_attr.attr.name);
+			device_remove_file(dev, &curve_attrs[i].dev_attr);
+		}
+    }
+    kfree(curve_attrs);
+    curve_attrs = NULL;
+	curve_attrs_count = 0;
+    return ret;
+}
+
+// Remove dynamically created attributes
+static void remove_fan_curve_attrs(struct device *dev)
+{
+    int i;
+    
+    if (curve_attrs) {
+        for (i = 0; i < curve_attrs_count; i++) {
+            device_remove_file(dev, &curve_attrs[i].dev_attr);
+            
+            if (curve_attrs[i].dev_attr.attr.name) {
+                kfree(curve_attrs[i].dev_attr.attr.name);
+            }
+        }
+        kfree(curve_attrs);
+        curve_attrs = NULL;
+        curve_attrs_count = 0;
+		pr_debug("msi-ec: Successfully removed all fan curve attributes\n");
+    }
+
+    device_remove_file(dev, &dev_attr_pwm1_auto_points_count);
+    device_remove_file(dev, &dev_attr_pwm2_auto_points_count);
+}
+
+// ============================================================ //
+// Hwmon functions (other)
+// ============================================================ //
 // Check if a specific fan mode is available in the configuration
 static bool fan_mode_is_available(const char *mode)
 {
@@ -5098,6 +5496,19 @@ static int __init msi_ec_init(void)
 		led_classdev_register(&msi_platform_device->dev,
 				      &msiacpi_led_kbdlight);
 
+	// if (conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) {
+	// 	int result = curve_init(cpu_curve_package);
+	// 	if (result < 0)
+	// 		return result;
+	// }
+
+	// if (conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) {
+	// 	int result = curve_init(gpu_curve_package);
+	// 	if (result < 0)
+	// 		return result;
+	// }
+
+
 	pr_info("msi-ec: Registering hwmon device\n");
 
 	// register hwmon device
@@ -5120,6 +5531,16 @@ static int __init msi_ec_init(void)
 		pr_err("msi-ec: hwmon device register failed with error %d\n", err);
 		return err;
 	}
+
+	// Add fan curve attributes if advanced mode is available
+	if (!IS_ERR(hwmon_dev) && fan_mode_is_available(FM_ADVANCED_NAME)) {
+		int result = create_fan_curve_attrs(hwmon_dev);
+		if (result < 0) {
+			hwmon_device_unregister(hwmon_dev);
+			return result;
+		}
+	}
+
 	pr_info("msi-ec: hwmon device registered successfully\n");
 
 	return 0;
-- 
2.39.1


From 5b289080b9715bf237328b735be4fdbb32593e9e Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 15:56:26 +0800
Subject: [PATCH 07/10] Fix: Module unload issues and hwmon naming

---
 ec_memory_configuration.h |  1 +
 msi-ec.c                  | 61 +++++++++++++++++++--------------------
 2 files changed, 30 insertions(+), 32 deletions(-)

diff --git a/ec_memory_configuration.h b/ec_memory_configuration.h
index f6b57a4..1e0faf3 100644
--- a/ec_memory_configuration.h
+++ b/ec_memory_configuration.h
@@ -5,6 +5,7 @@
 #include <linux/device.h>
 
 #define MSI_EC_DRIVER_NAME "msi-ec"
+#define MSI_EC_HWMON_NAME "msi_ec"
 
 #define MSI_EC_ADDR_UNKNOWN 0xff01 // unknown address
 #define MSI_EC_ADDR_UNSUPP  0xff01 // unsupported parameter
diff --git a/msi-ec.c b/msi-ec.c
index fc8143f..a90edd7 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -4662,10 +4662,10 @@ static int msi_platform_remove(struct platform_device *pdev)
 	if (debug)
 		sysfs_remove_group(&pdev->dev.kobj, &msi_debug_group);
 	
-	// Remove fan curve attributes
-    if (hwmon_dev) {
-        remove_fan_curve_attrs(hwmon_dev);
-    }
+	// // Remove fan curve attributes
+    // if (hwmon_dev) {
+    //     remove_fan_curve_attrs(hwmon_dev);
+    // }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0))
 	return 0;
@@ -5072,23 +5072,28 @@ cleanup:
 static void remove_fan_curve_attrs(struct device *dev)
 {
     int i;
+
+	if (!dev) {
+        pr_err("msi-ec: Cannot remove attributes, device pointer is NULL\n");
+        return;
+    }
+
+	if (!curve_attrs) {
+        pr_info("msi-ec: No fan curve attributes to remove\n");
+        return;
+    }
     
-    if (curve_attrs) {
-        for (i = 0; i < curve_attrs_count; i++) {
-            device_remove_file(dev, &curve_attrs[i].dev_attr);
-            
-            if (curve_attrs[i].dev_attr.attr.name) {
-                kfree(curve_attrs[i].dev_attr.attr.name);
-            }
+    pr_info("msi-ec: Removing %d fan curve attributes\n", curve_attrs_count);
+    for (i = 0; i < curve_attrs_count; i++) {
+        if (curve_attrs[i].dev_attr.attr.name) {
+            // device_remove_file(dev, &curve_attrs[i].dev_attr);
+            kfree(curve_attrs[i].dev_attr.attr.name);
         }
-        kfree(curve_attrs);
-        curve_attrs = NULL;
-        curve_attrs_count = 0;
-		pr_debug("msi-ec: Successfully removed all fan curve attributes\n");
     }
-
-    device_remove_file(dev, &dev_attr_pwm1_auto_points_count);
-    device_remove_file(dev, &dev_attr_pwm2_auto_points_count);
+    kfree(curve_attrs);
+    curve_attrs = NULL;
+    curve_attrs_count = 0;
+	pr_info("msi-ec: Successfully removed all fan curve attributes\n");
 }
 
 // ============================================================ //
@@ -5496,19 +5501,6 @@ static int __init msi_ec_init(void)
 		led_classdev_register(&msi_platform_device->dev,
 				      &msiacpi_led_kbdlight);
 
-	// if (conf.cpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) {
-	// 	int result = curve_init(cpu_curve_package);
-	// 	if (result < 0)
-	// 		return result;
-	// }
-
-	// if (conf.gpu.rt_fan_speed_address != MSI_EC_ADDR_UNSUPP) {
-	// 	int result = curve_init(gpu_curve_package);
-	// 	if (result < 0)
-	// 		return result;
-	// }
-
-
 	pr_info("msi-ec: Registering hwmon device\n");
 
 	// register hwmon device
@@ -5517,7 +5509,7 @@ static int __init msi_ec_init(void)
 		return -ENOMEM;
 	
 	hwmon_data->dev = &msi_platform_device->dev;
-	hwmon_data->name = MSI_EC_DRIVER_NAME;
+	hwmon_data->name = MSI_EC_HWMON_NAME;
 	
 	dev_set_drvdata(&msi_platform_device->dev, hwmon_data);
 	
@@ -5563,6 +5555,11 @@ static void __exit msi_ec_exit(void)
 			battery_hook_unregister(&battery_hook);
 	}
 
+	if (hwmon_dev) {
+        pr_info("msi-ec: Removing fan curve attributes before unregistering hwmon\n");
+        remove_fan_curve_attrs(hwmon_dev);
+    }
+
 	// unregister hwmon device
 	if (hwmon_dev)
 		hwmon_device_unregister(hwmon_dev);
-- 
2.39.1


From 495135904b67ade64ebe0db8fc24bb9210bc7546 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 16:36:01 +0800
Subject: [PATCH 08/10] Add: PWM value scaling between hwmon and EC

Scale PWM values between hwmon standard (0-255) and EC device (0-100) ranges when reading and writing fan curve points.
---
 msi-ec.c | 35 ++++++++++++++++++++++-------------
 1 file changed, 22 insertions(+), 13 deletions(-)

diff --git a/msi-ec.c b/msi-ec.c
index a90edd7..e55f11f 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -4661,11 +4661,6 @@ static int msi_platform_remove(struct platform_device *pdev)
 {
 	if (debug)
 		sysfs_remove_group(&pdev->dev.kobj, &msi_debug_group);
-	
-	// // Remove fan curve attributes
-    // if (hwmon_dev) {
-    //     remove_fan_curve_attrs(hwmon_dev);
-    // }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0))
 	return 0;
@@ -4819,8 +4814,12 @@ static ssize_t curve_attr_show(struct device *dev,
 		pr_debug("msi-ec: Failed to read EC value from address: 0x%04x\n", address);
 		return ret;
 	}
-	pr_debug("msi-ec: Read EC value from address: 0x%04x, value: %u\n", address, value);
-    
+
+	unsigned int orig_val = value;
+	value = value * 255 / 100;
+
+	pr_debug("msi-ec: Reading PWM from address: 0x%04x, scaled value: %u (from %u)\n", 
+			 address, value, orig_val);
     return sysfs_emit(buf, "%u\n", value);
 }
 
@@ -4861,9 +4860,13 @@ static ssize_t curve_attr_store(struct device *dev,
             // Validate PWM value (0-255)
             if (val > 255)
                 return -EINVAL;
+
+			unsigned long orig_val = val;
+			val = val * 100 / 255;
             
             address = conf.cpu.fan_curve.speed_start_address + (point - 1);
-			pr_debug("msi-ec: Writing CPU PWM to address: 0x%04x, value: %lu\n", address, val);
+			pr_debug("msi-ec: Writing CPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
+				address, val, orig_val);
         } else {
             // Last point has no temperature value
             if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
@@ -4887,8 +4890,13 @@ static ssize_t curve_attr_store(struct device *dev,
                 
             if (val > 255)
                 return -EINVAL;
+			
+			unsigned long orig_val = val;
+			val = val * 100 / 255;
                 
             address = conf.gpu.fan_curve.speed_start_address + (point - 1);
+			pr_debug("msi-ec: Writing GPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
+					address, val, orig_val);
         } else {
             if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
                 return -EINVAL;
@@ -4897,6 +4905,7 @@ static ssize_t curve_attr_store(struct device *dev,
                 return -EINVAL;
                 
             address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
+			pr_debug("msi-ec: Writing GPU temperature to address: 0x%04x, value: %lu\n", address, val);
         }
     }
     
@@ -5059,7 +5068,7 @@ cleanup:
     for (i = 0; i < idx; i++) {
 		if (curve_attrs[i].dev_attr.attr.name) {
 			kfree(curve_attrs[i].dev_attr.attr.name);
-			device_remove_file(dev, &curve_attrs[i].dev_attr);
+			// device_remove_file(dev, &curve_attrs[i].dev_attr);
 		}
     }
     kfree(curve_attrs);
@@ -5074,16 +5083,16 @@ static void remove_fan_curve_attrs(struct device *dev)
     int i;
 
 	if (!dev) {
-        pr_err("msi-ec: Cannot remove attributes, device pointer is NULL\n");
+        pr_debug("msi-ec: Cannot remove attributes, device pointer is NULL\n");
         return;
     }
 
 	if (!curve_attrs) {
-        pr_info("msi-ec: No fan curve attributes to remove\n");
+        pr_debug("msi-ec: No fan curve attributes to remove\n");
         return;
     }
     
-    pr_info("msi-ec: Removing %d fan curve attributes\n", curve_attrs_count);
+    pr_debug("msi-ec: Removing %d fan curve attributes\n", curve_attrs_count);
     for (i = 0; i < curve_attrs_count; i++) {
         if (curve_attrs[i].dev_attr.attr.name) {
             // device_remove_file(dev, &curve_attrs[i].dev_attr);
@@ -5093,7 +5102,7 @@ static void remove_fan_curve_attrs(struct device *dev)
     kfree(curve_attrs);
     curve_attrs = NULL;
     curve_attrs_count = 0;
-	pr_info("msi-ec: Successfully removed all fan curve attributes\n");
+	pr_debug("msi-ec: Successfully removed all fan curve attributes\n");
 }
 
 // ============================================================ //
-- 
2.39.1


From cc12a53247df20a64c106d7f59f9e8724599fddc Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 7 Mar 2025 17:45:52 +0800
Subject: [PATCH 09/10] Refactor: Use lazy-sync for fan curve hwmon attributes

Refactored the hwmon implementation of fan curve attributes to:
1. Utilize existing curve buffer mechanism instead of direct EC access
2. Implement lazy-sync through push_ec_curve_safe to prevent issues on non-advanced modes
3. Fix PWM value scaling between hwmon (0-255) and EC (0-100) ranges
4. Add proper range validation and error handling

This change improves system stability and maintains consistency with the existing fan control mechanisms.
---
 msi-ec.c | 177 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 116 insertions(+), 61 deletions(-)

diff --git a/msi-ec.c b/msi-ec.c
index e55f11f..57d6846 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -3951,10 +3951,14 @@ static int sync_ec_curve_safe(struct msi_ec_fan_curve curve, u8 *fan_speed_buf,
 static int push_ec_curve_safe(struct msi_ec_fan_curve curve, const u8 *fan_speed_buf, const u8 *temperature_buf) {
 	const char *fan_mode;
 
+	pr_info("msi-ec: (push_ec_curve_safe) checking fan mode, apply_strategy: %d\n", curve.apply_strategy);
 	if (curve.apply_strategy == CURVE_APPLY_STRATEGY_RESET_ON_AUTO) {
 		if (fan_mode_get(&fan_mode)) return -ENODATA;
 
-		if (strcmp(fan_mode, FM_ADVANCED_NAME)) return 0;
+		if (strcmp(fan_mode, FM_ADVANCED_NAME)) {
+			pr_info("msi-ec: (push_ec_curve_safe) fan mode is [%s], not advanced, skipping\n", fan_mode);
+			return 0;
+		}
 	}
 
 	return push_ec_curve(curve, fan_speed_buf, temperature_buf);
@@ -4767,59 +4771,82 @@ static ssize_t curve_attr_show(struct device *dev,
     int is_pwm = curve_attr->is_pwm;
     u8 value;
     int ret;
-    u16 address;
+    // u16 address;
 
 	pr_debug("msi-ec: curve_attr_show - fan=%d, point=%d, is_pwm=%d\n", 
              fan, point, is_pwm);
-    
-    // Select proper address based on fan, point and type (PWM or temp)
-    if (fan == 0) { // CPU fan
-        if (is_pwm) {
-            // Make sure point is within range
-            if (point < 1 || point > conf.cpu.fan_curve.entries_count) {
-				pr_debug("msi-ec: Invalid CPU PWM point: %d, max allowed: %d\n", 
-                         point, conf.cpu.fan_curve.entries_count);
-				return -EINVAL;
-			}
+    // // Select proper address based on fan, point and type (PWM or temp)
+    // if (fan == 0) { // CPU fan
+    //     if (is_pwm) {
+    //         // Make sure point is within range
+    //         if (point < 1 || point > conf.cpu.fan_curve.entries_count) {
+	// 			pr_debug("msi-ec: Invalid CPU PWM point: %d, max allowed: %d\n", 
+    //                      point, conf.cpu.fan_curve.entries_count);
+	// 			return -EINVAL;
+	// 		}
                 
-            address = conf.cpu.fan_curve.speed_start_address + (point - 1);
-			pr_debug("msi-ec: Reading CPU PWM from address: 0x%04x\n", address);
-        } else {
-            // Last point has no temperature value
-            if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
-				pr_debug("msi-ec: Invalid CPU temperature point: %d, max allowed: %d\n", 
-                         point, conf.cpu.fan_curve.entries_count);
-				return -EINVAL;
-			}
+    //         address = conf.cpu.fan_curve.speed_start_address + (point - 1);
+	// 		pr_debug("msi-ec: Reading CPU PWM from address: 0x%04x\n", address);
+    //     } else {
+    //         // Last point has no temperature value
+    //         if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
+	// 			pr_debug("msi-ec: Invalid CPU temperature point: %d, max allowed: %d\n", 
+    //                      point, conf.cpu.fan_curve.entries_count);
+	// 			return -EINVAL;
+	// 		}
                 
-            address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
-        }
-    } else { // GPU fan
-        if (is_pwm) {
-            if (point < 1 || point > conf.gpu.fan_curve.entries_count)
-                return -EINVAL;
+    //         address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
+    //     }
+    // } else { // GPU fan
+    //     if (is_pwm) {
+    //         if (point < 1 || point > conf.gpu.fan_curve.entries_count)
+    //             return -EINVAL;
                 
-            address = conf.gpu.fan_curve.speed_start_address + (point - 1);
-        } else {
-            if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
-                return -EINVAL;
+    //         address = conf.gpu.fan_curve.speed_start_address + (point - 1);
+    //     } else {
+    //         if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
+    //             return -EINVAL;
                 
-            address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
-        }
-    }
+    //         address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
+    //     }
+    // }
     
-    // Read value from EC
-    ret = ec_read(address, &value);
-    if (ret < 0) {
-		pr_debug("msi-ec: Failed to read EC value from address: 0x%04x\n", address);
-		return ret;
-	}
+    // // Read value from EC
+    // ret = ec_read(address, &value);
+    // if (ret < 0) {
+	// 	pr_debug("msi-ec: Failed to read EC value from address: 0x%04x\n", address);
+	// 	return ret;
+	// }
+
+	struct curve_pack *curve_data = (fan == 0) ? &cpu_curve_package : &gpu_curve_package;
+	struct msi_ec_fan_curve *conf_curve = (fan == 0) ? &conf.cpu.fan_curve : &conf.gpu.fan_curve;
+
+	if (is_pwm) {
+		if (point < 1 || point > conf_curve->entries_count) {
+			pr_err("msi-ec: Invalid PWM point: %d, max allowed: %d\n", 
+					 point, conf_curve->entries_count);
+			return -EINVAL;
+		}
+
+		value = curve_data->curve_fan_speed[point - 1];
+		unsigned int orig_val = value;
+		value = value * 255 / 100;
+		pr_debug("msi-ec: Reading PWM from buffer, index: %d, scaled value: %u (from %u)\n", 
+                 point - 1, value, orig_val);
+	} else {
+		if (point < 1 || point >= conf_curve->entries_count) {
+			pr_err("msi-ec: Invalid temperature point: %d, max allowed: %d\n", 
+					 point, conf_curve->entries_count);
+			return -EINVAL;
+		}
 
-	unsigned int orig_val = value;
-	value = value * 255 / 100;
+		value = curve_data->curve_temp[point - 1];
+		pr_debug("msi-ec: Reading temperature from buffer, index: %d, value: %u\n", 
+                 point - 1, value);
+	}
 
-	pr_debug("msi-ec: Reading PWM from address: 0x%04x, scaled value: %u (from %u)\n", 
-			 address, value, orig_val);
+	// pr_debug("msi-ec: Reading PWM from address: 0x%04x, scaled value: %u (from %u)\n", 
+	// 		 address, value, orig_val);
     return sysfs_emit(buf, "%u\n", value);
 }
 
@@ -4837,13 +4864,18 @@ static ssize_t curve_attr_store(struct device *dev,
     int ret;
     u16 address;
 
-	pr_debug("msi-ec: curve_attr_store - fan=%d, point=%d, is_pwm=%d\n", 
+	pr_info("msi-ec: (curve_attr_store) fan=%d, point=%d, is_pwm=%d\n", 
              fan, point, is_pwm);
+
+	struct curve_pack *curve_data = (fan == 0) ? &cpu_curve_package : &gpu_curve_package;
+	struct msi_ec_fan_curve *curve = curve_data->curve;
+	u8 *fan_speed_buf = curve_data->curve_fan_speed;
+	u8 *temp_buf = curve_data->curve_temp;
     
     // Parse value from user
     ret = kstrtoul(buf, 10, &val);
     if (ret < 0) {
-		pr_debug("msi-ec: Failed to parse value from user\n");
+		pr_err("msi-ec: Failed to parse value from user\n");
 		return ret;
 	}
     
@@ -4863,10 +4895,14 @@ static ssize_t curve_attr_store(struct device *dev,
 
 			unsigned long orig_val = val;
 			val = val * 100 / 255;
+
+			fan_speed_buf[point - 1] = (u8)val;
+			pr_info("msi-ec: Updating CPU PWM in buffer, index: %d, scaled value: %lu (from %lu)\n", 
+                     point - 1, val, orig_val);
             
-            address = conf.cpu.fan_curve.speed_start_address + (point - 1);
-			pr_debug("msi-ec: Writing CPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
-				address, val, orig_val);
+            // address = conf.cpu.fan_curve.speed_start_address + (point - 1);
+			// pr_debug("msi-ec: Writing CPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
+			// 	address, val, orig_val);
         } else {
             // Last point has no temperature value
             if (point < 1 || point >= conf.cpu.fan_curve.entries_count) {
@@ -4878,9 +4914,13 @@ static ssize_t curve_attr_store(struct device *dev,
             // Validate temperature value (0-100°C)
             if (val > 100)
                 return -EINVAL;
+
+			temp_buf[point - 1] = (u8)val;
+			pr_info("msi-ec: Updating CPU temperature in buffer, index: %d, value: %lu\n", 
+                     point - 1, val);
                 
-            address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
-			pr_debug("msi-ec: Writing CPU temperature to address: 0x%04x, value: %lu\n", address, val);
+            // address = conf.cpu.fan_curve.temperature_start_address + (point - 1);
+			// pr_debug("msi-ec: Writing CPU temperature to address: 0x%04x, value: %lu\n", address, val);
         }
     } else { // GPU fan
         // Similar validation for GPU fan...
@@ -4893,28 +4933,43 @@ static ssize_t curve_attr_store(struct device *dev,
 			
 			unsigned long orig_val = val;
 			val = val * 100 / 255;
+
+			fan_speed_buf[point - 1] = (u8)val;
+			pr_debug("msi-ec: Updating GPU PWM in buffer, index: %d, scaled value: %lu (from %lu)\n", 
+			         point - 1, val, orig_val);
                 
-            address = conf.gpu.fan_curve.speed_start_address + (point - 1);
-			pr_debug("msi-ec: Writing GPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
-					address, val, orig_val);
+            // address = conf.gpu.fan_curve.speed_start_address + (point - 1);
+			// pr_debug("msi-ec: Writing GPU PWM to address: 0x%04x, scaled value: %lu (from %lu)\n", 
+			// 		address, val, orig_val);
         } else {
             if (point < 1 || point >= conf.gpu.fan_curve.entries_count)
                 return -EINVAL;
                 
             if (val > 100)
                 return -EINVAL;
+
+			temp_buf[point - 1] = (u8)val;
+			pr_debug("msi-ec: Updating GPU temperature in buffer, index: %d, value: %lu\n", 
+                     point - 1, val);
                 
-            address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
-			pr_debug("msi-ec: Writing GPU temperature to address: 0x%04x, value: %lu\n", address, val);
+            // address = conf.gpu.fan_curve.temperature_start_address + (point - 1);
+			// pr_debug("msi-ec: Writing GPU temperature to address: 0x%04x, value: %lu\n", address, val);
         }
     }
     
-    // Write value to EC
-    ret = ec_write(address, val);
+    // // Write value to EC
+    // ret = ec_write(address, val);
+    // if (ret < 0) {
+	// 	pr_debug("msi-ec: Failed to write EC value to address: 0x%04x\n", address);
+	// 	return ret;
+	// }
+
+	// Push curve to EC safely
+	ret = push_ec_curve_safe(*curve, fan_speed_buf, temp_buf);
     if (ret < 0) {
-		pr_debug("msi-ec: Failed to write EC value to address: 0x%04x\n", address);
-		return ret;
-	}
+        pr_err("msi-ec: Failed to push curve to EC, error: %d\n", ret);
+        return ret;
+    }
     
     return count;
 }
-- 
2.39.1


From 472d15f137b58d7de0f52aac4f8e75949f0709e7 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Thu, 6 Mar 2025 17:36:44 +0800
Subject: [PATCH 10/10] Add fan_curve for claw8

---
 msi-ec.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/msi-ec.c b/msi-ec.c
index 57d6846..d2037a1 100644
--- a/msi-ec.c
+++ b/msi-ec.c
@@ -2946,10 +2946,22 @@ static struct msi_ec_conf CONF401 __initdata = {
 	.cpu = {
 		.rt_temp_address       = 0x68,
 		.rt_fan_speed_address  = 0x71,
+		.fan_curve = {
+			.speed_start_address = 0x72,
+			.temperature_start_address = 0x6a,
+			.entries_count = 7,
+			.apply_strategy = CURVE_APPLY_STRATEGY_RESET_ON_AUTO
+		}
 	},
 	.gpu = {
 		.rt_temp_address      = 0x80,
 		.rt_fan_speed_address = 0x89,
+		.fan_curve = {
+			.speed_start_address = 0x8a,
+			.temperature_start_address = 0x82,
+			.entries_count = 7,
+			.apply_strategy = CURVE_APPLY_STRATEGY_RESET_ON_AUTO
+		}
 	},
 	.leds = {
 		.micmute_led_address = MSI_EC_ADDR_UNSUPP,
-- 
2.39.1

